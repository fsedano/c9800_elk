input { 
  file {
    path => "/logstash_host/logstash_data/logdemo.log"
    start_position => "beginning"
    sincedb_path => "/root/data/sincedb.db"
  }

 }

filter {
  grok {
    patterns_dir => ["/root/patterns"]
    match => { "message" => ["%{CISCO_DATE:event_date} %{CISCO_PROCESS_NAME:process}%{INSTANCE_ID:instance}: %{LIB:lib} %{PID:pid}: %{LOG_LEVEL}: %{CAPWAP_MSG:mensaje}", 
                             "%{CISCO_DATE:event_date} %{CISCO_PROCESS_NAME:process}%{INSTANCE_ID:instance}: %{LIB:lib} %{PID:pid}: %{LOG_LEVEL}: %{CLIENT_STATE_TRANSITION_MSG:mensaje}"]
    }
  }
  date {
        match => ["event_date" , "yy/MM/dd HH:mm:ss.SSS"]
  }
  ruby {    
    code => "event.set('event_timestamp_unix',event.get('@timestamp').to_i)"  
  }     

  if "_grokparsefailure" in [tags] { drop {} }
  fingerprint {
    source => "message"
    target => "[@metadata][fingerprint]"
    method => "MURMUR3"
  }

  if [to_state] =="STATE_2" {
    aggregate {
      task_id =>  "%{client_mac}"
      code => "map['event_duration'] = 0; map['prev_event_ts']=event.get('event_timestamp_unix'); event.set('scaled_time',0); map['scaled_time']=0"
      map_action => "create"
    }
  }

  if [to_state] =="STATE_3" {
    aggregate {
      task_id =>  "%{client_mac}"
      code => "event.set('event_duration', event.get('event_timestamp_unix')-map['prev_event_ts']); map['scaled_time'] +=  (event.get('event_timestamp_unix')-map['prev_event_ts']); event.set('scaled_time', map['scaled_time']); map['prev_event_ts']=event.get('event_timestamp_unix'); "
      map_action => "update"
    }
  }

  if [to_state] =="STATE_4" {
    aggregate {
      task_id =>  "%{client_mac}"
      code => "event.set('event_duration', event.get('event_timestamp_unix')-map['prev_event_ts']);map['scaled_time'] += (event.get('event_timestamp_unix')-map['prev_event_ts']); event.set('scaled_time', map['scaled_time'])"
      map_action => "update"
      end_of_task => true
      timeout => 120
    }
  }



}
output {
  elasticsearch { 
    hosts => ["elasticsearch:9200"]
    document_id => "%{[@metadata][fingerprint]}"
  }
  stdout { codec => rubydebug }
}