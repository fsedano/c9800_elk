input { 
  file {
    path => "/root/data/wncd_local_cli_intra_wncd_roam.log"
    start_position => "beginning"
    sincedb_path => "/root/data/sincedb.db"
    #sincedb_path => "/dev/null"
  }

 }

filter {
  grok {
    patterns_dir => ["/root/patterns"]
    match => { "message" => [
       "%{CLIENT_TRACE_HDR} MAC: %{MAC:client_mac}  %{GREEDYDATA:event_type} BSSID %{MAC:bssid}, old BSSID %{MAC:old_bssid}, WLAN %{NUMBER:wlan_id}, Slot %{NUMBER:slot} AP %{MAC:ap_mac_slot}, %{WORD_:ap_name}",
       "%{CLIENT_TRACE_HDR} MAC: %{MAC:client_mac}  %{GREEDYDATA:event_type} Method: %{GREEDYDATA:method} IP: %{IP:client_ip}",
       "%{CLIENT_TRACE_HDR} MAC: %{MAC:client_mac}  %{GREEDYDATA:event_type} Inside client %{WORD_:state} state",
       "%{CLIENT_TRACE_HDR} MAC: %{MAC:client_mac}  %{GREEDYDATA:event_type} Reason: %{WORD_:reason}"                             
      ]
    }
  }
  date {
        match => ["event_date" , "yy/MM/dd HH:mm:ss.SSS"]
  }
  
  ruby {    
    code => "event.set('event_timestamp_unix',event.get('@timestamp').to_f*1000)"
  }     

  if "_grokparsefailure" in [tags] { drop {} }
  fingerprint {
    source => "message"
    target => "[@metadata][fingerprint]"
    method => "MURMUR3"
  }

  if [event_type] =="Association received." {
    aggregate {
      task_id =>  "%{client_mac}"
      code => "map['internal_uuid']=SecureRandom.hex; event.set('internal_uuid', map['internal_uuid']); map['event_duration'] = 0; map['prev_event_ts']=event.get('event_timestamp_unix'); map['overall_start'] = event.get('event_timestamp_unix'); event.set('scaled_time',0); map['scaled_time']=0; map['current_ap'] = event.get('ap_name'); event.set('current_ap', map['current_ap'])"
      map_action => "create"
    }
  }

  if [event_type] =="Client IP learn successful." {
    aggregate {
      task_id =>  "%{client_mac}"
      code => "event.set('internal_uuid', map['internal_uuid']); map['client_ip'] = event.get('client_ip'); event.set('event_duration', event.get('event_timestamp_unix') - map['prev_event_ts']); map['prev_event_ts']=event.get('event_timestamp_unix'); event.set('current_ap', map['current_ap']); event.set('scaled_time',event.get('event_timestamp_unix')-map['overall_start'])"
      map_action => "update"
    }
  }



  if [event_type] =="process client run." {
    aggregate {
      task_id =>  "%{client_mac}"
      code => "event.set('internal_uuid', map['internal_uuid']); event.set('event_duration', event.get('event_timestamp_unix') - map['prev_event_ts']); map['prev_event_ts']=event.get('event_timestamp_unix'); event.set('current_ap', map['current_ap']); event.set('scaled_time',event.get('event_timestamp_unix')-map['overall_start'])"
      map_action => "update"
    }
  }

  if [event_type] =="Re-Association received." {
    aggregate {
      task_id =>  "%{client_mac}"
      code => "event.set('internal_uuid', map['internal_uuid']); event.set('event_duration', event.get('event_timestamp_unix') - map['prev_event_ts']); map['prev_event_ts']=event.get('event_timestamp_unix'); map['current_ap'] = event.get('ap_name'); event.set('current_ap', map['current_ap']); event.set('scaled_time',event.get('event_timestamp_unix')-map['overall_start'])"
      map_action => "update"
    }
  }

  if [event_type] =="Client delete initiated." {
    aggregate {
      task_id =>  "%{client_mac}"
      code => "event.set('internal_uuid', map['internal_uuid']); event.set('event_duration', event.get('event_timestamp_unix') - map['prev_event_ts']); map['prev_event_ts']=event.get('event_timestamp_unix'); event.set('current_ap', map['current_ap']); event.set('scaled_time',event.get('event_timestamp_unix')-map['overall_start'])"
      map_action => "update"
      end_of_task => true
    }
  }



}
output {
  elasticsearch { 
    hosts => ["elasticsearch:9200"]
    document_id => "%{[@metadata][fingerprint]}"
  }
  stdout { codec => rubydebug }
}